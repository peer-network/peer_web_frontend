<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>Image Crop Editor – Zoom via Mouse & Touch (Transform-Origin)</title>
    <style>
      /* Container: Definiert den runden, sichtbaren Ausschnitt */
      #cropContainer {
        width: 300px;
        height: 300px;
        border: 2px dashed #333;
        position: relative;
        overflow: hidden;
        clip-path: circle(50% at 50% 50%);
        touch-action: none; /* Verhindert Standard-Gesten */
        margin-bottom: 10px;
      }
      /* Das Bild wird absolut positioniert, um Drag & Zoom zu ermöglichen */
      #cropContainer img {
        position: absolute;
        cursor: move;
      }
      /* Ergebnisbereich-Styling */
      #result {
        margin-top: 15px;
        border: 1px solid #999;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <h2>Image Crop Editor – Zoom via Mouse & Touch mit Transform-Origin</h2>

    <!-- Bild per Datei-Upload laden -->
    <label>Datei auswählen:</label>
    <input type="file" id="profileImageInput" accept="image/*" />
    <br />
    <br />

    <!-- Crop-Container mit runder Clip-Path -->
    <div id="cropContainer">
      <img id="image" src="" alt="Bild für Crop" style="display: none" />
    </div>

    <!-- Button zum Anzeigen des aktuellen Crop-Ausschnitts -->
    <button id="cropButton">Ergebnis anzeigen</button>

    <h3>Ergebnis:</h3>
    <div id="result"></div>

    <script>
      // Referenzen auf DOM-Elemente
      const profileImageInput = document.getElementById("profileImageInput");
      const image = document.getElementById("image");
      const cropContainer = document.getElementById("cropContainer");
      const result = document.getElementById("result");

      // Globale Variablen für Translation und Zoom
      let offsetX = 0,
        offsetY = 0;
      let currentZoom = 1;

      // Variablen für Dragging
      let isDragging = false,
        startX = 0,
        startY = 0;

      // Variablen für Touch-Pinch
      let isPinching = false;
      let lastTouchDistance = 0;

      // Aktualisiert die Transformation des Bildes (Translation & Scale)
      function updateTransform() {
        image.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${currentZoom})`;
      }

      // Bild laden
      profileImageInput.addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (evt) {
            image.src = evt.target.result;
            image.style.display = "block";
            // Reset initial values
            offsetX = 0;
            offsetY = 0;
            currentZoom = 1;
            updateTransform();
            image.onload = function () {
              // Optional: Bild innerhalb des Containers zentrieren
              offsetX = (cropContainer.clientWidth - image.naturalWidth) / 2;
              offsetY = (cropContainer.clientHeight - image.naturalHeight) / 2;
              updateTransform();
            };
          };
          reader.readAsDataURL(file);
        }
      });

      // ------------------- Maussteuerung -------------------
      image.addEventListener("mousedown", function (e) {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        e.preventDefault();
      });

      document.addEventListener("mousemove", function (e) {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        startX = e.clientX;
        startY = e.clientY;
        offsetX += dx;
        offsetY += dy;
        updateTransform();
      });

      document.addEventListener("mouseup", function () {
        isDragging = false;
      });

      // Zoom via Mausrad – Setzt transform-origin anhand der Mausposition
      cropContainer.addEventListener("wheel", function (e) {
        e.preventDefault();
        const rect = cropContainer.getBoundingClientRect();
        // Mausposition relativ zum Container
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        // Berechne den Punkt im Bild (unter Berücksichtigung der aktuellen Verschiebung)
        const originX = mouseX - offsetX;
        const originY = mouseY - offsetY;
        image.style.transformOrigin = `${originX}px ${originY}px`;

        // Aktualisiere den Zoomfaktor
        if (e.deltaY < 0) {
          currentZoom *= 1.1;
        } else {
          currentZoom /= 1.1;
        }
        // Begrenzung des Zooms
        currentZoom = Math.min(Math.max(currentZoom, 0.5), 3);
        updateTransform();
      });

      // ------------------- Touch-Steuerung -------------------
      image.addEventListener(
        "touchstart",
        function (e) {
          if (e.touches.length === 1) {
            // Ein Finger: Beginne Dragging
            isDragging = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          } else if (e.touches.length === 2) {
            // Zwei Finger: Beginne Pinch-Zoom
            isPinching = true;
            isDragging = false; // Deaktiviere Dragging während des Pinch-Zooms
            const [touch1, touch2] = e.touches;
            lastTouchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          }
          e.preventDefault();
        },
        { passive: false }
      );

      image.addEventListener(
        "touchmove",
        function (e) {
          if (isDragging && e.touches.length === 1) {
            // Verschiebe das Bild mit einem Finger (Drag)
            const touch = e.touches[0];
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;
            startX = touch.clientX;
            startY = touch.clientY;
            offsetX += dx;
            offsetY += dy;
            updateTransform();
          } else if (isPinching && e.touches.length === 2) {
            // Pinch-Zoom mit zwei Fingern
            const [touch1, touch2] = e.touches;
            const newDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            // Berechne den Mittelpunkt der beiden Finger relativ zum Container
            const rect = cropContainer.getBoundingClientRect();
            const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
            const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
            // Berechne den Punkt im Bild (unter Berücksichtigung der Verschiebung)
            const originX = centerX - offsetX;
            const originY = centerY - offsetY;
            image.style.transformOrigin = `${originX}px ${originY}px`;

            // Aktualisiere den Zoomfaktor anhand des Abstands
            const zoomFactor = newDistance / lastTouchDistance;
            currentZoom *= zoomFactor;
            currentZoom = Math.min(Math.max(currentZoom, 0.5), 3);
            lastTouchDistance = newDistance;
            updateTransform();
          }
          e.preventDefault();
        },
        { passive: false }
      );

      image.addEventListener(
        "touchend",
        function (e) {
          // Wenn alle Finger weg sind, beende alle Gesten
          if (e.touches.length === 0) {
            isDragging = false;
            isPinching = false;
          }
          // Falls noch ein Finger übrig ist, wird wieder Dragging aktiviert
          if (e.touches.length === 1) {
            isPinching = false;
            isDragging = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          }
          e.preventDefault();
        },
        { passive: false }
      );

      // ------------------- Ergebnisanzeige -------------------
      document.getElementById("cropButton").addEventListener("click", function () {
        const clonedCrop = cropContainer.cloneNode(true);
        const clonedImage = clonedCrop.querySelector("img");
        if (clonedImage) {
          clonedImage.style.cursor = "default";
        }
        result.innerHTML = "";
        result.appendChild(clonedCrop);
      });
    </script>
  </body>
</html>
